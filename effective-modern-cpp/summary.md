# Effective Modern C++ Notes

# 类型推导
模板类型推导
有三种情况
- 引用或指针: T忽略引用或指针，形参类型从实参得出
- 通用引用：除了纯右值除掉引用，其它T带引用
- 不是引用或指针：按值传递，cv修饰符被去掉
- 数组和函数退化为指针

auto
- auto类型推导通常和模板类型推导相同，除了假定花括号初始化代表std::initializer_list
- 在C++14中auto允许出现在函数返回值或者lambda函数形参中，它的工作机制是模板类型推导

decltype
- 对于T类型非单纯变量名的左值表达式，decltype产生的是 T&
- 使用deltype(auto)需注意

可以借助工具查看推导类型，主要方式如下，但重要的还是理解推导规则  
- IDE
- 编译器报错信息
- 第三方库，如boost TypeIndex

# 现代C++
类的特殊成员函数，C++11前有四个，C++11增加了移动构造和移动赋值
- 构造函数：类中为声明构造函数时，自动生成
- 析构函数：C++11后默认析构为noexcept
- 拷贝构造：用户声明了拷贝构造或析构函数，不会自动生成；声明了移动操作，自动被delete；默认行为时逐一拷贝non-static成员
- 拷贝赋值：和拷贝构造行为一致，但独立
- 移动构造：未自定义拷贝、移动和析构函数时才自动生成；默认行为是逐一移动non-static成员
- 移动赋值：和移动构造一致，且相互关联

一些现代C++做法：
- 使用nullptr,而不是0或者NULL，避免重载指针和整形
- 优先使用using别名而不是typedef，别名模板避免::type后最和typename, C++14后type_traits有别名声明
- 优先使用限域enum,防止名称污染，底层类型默认是int
- 不需要的特殊成员函数使用delete显示删除
- 尽量使用const_iterator,非成员版本的begin,end适应范围更广，内置数组类型也支持
- constexpr修饰变量表示编译期常量，constexpr修饰函数表示当参数也是编译期常量时，它可以返回编译期的常量，但也可以作为运行期的函数；C++11时，此类函数只有一个return语句，C++14后限制很宽松
- atomic比mutext性能更好，但它只适合单变量
- 使用override显式重写父类函数，编译期会帮你检查函数签名

初始化方式
- ()：它防止了隐式的变窄转换，而且对于C++最令人头疼的解析也天生免疫，注意二义性问题
- = ：一般不能直接给类
- {}: 统一初始化，编译器热衷于把括号初始化与使std::initializer_list构造函数匹配

exception
