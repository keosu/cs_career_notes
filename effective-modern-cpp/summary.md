# Effective Modern C++ Notes

# 类型推导
模板类型推导
有三种情况
- 引用或指针: T忽略引用或指针，形参类型从实参得出
- 通用引用：除了纯右值除掉引用，其它T带引用
- 不是引用或指针：按值传递，cv修饰符被去掉
- 数组和函数退化为指针

auto
- auto类型推导通常和模板类型推导相同，除了假定花括号初始化代表std::initializer_list
- 在C++14中auto允许出现在函数返回值或者lambda函数形参中，它的工作机制是模板类型推导

decltype
- 对于T类型非单纯变量名的左值表达式，decltype产生的是 T&
- 使用deltype(auto)需注意

可以借助工具查看推导类型，主要方式如下，但重要的还是理解推导规则  
- IDE
- 编译器报错信息
- 第三方库，如boost TypeIndex

# 现代C++
类的特殊成员函数，C++11前有四个，C++11增加了移动构造和移动赋值
- 构造函数：类中为声明构造函数时，自动生成
- 析构函数：C++11后默认析构为noexcept
- 拷贝构造：用户声明了拷贝构造或析构函数，不会自动生成；声明了移动操作，自动被delete；默认行为时逐一拷贝non-static成员
- 拷贝赋值：和拷贝构造行为一致，但独立
- 移动构造：未自定义拷贝、移动和析构函数时才自动生成；默认行为是逐一移动non-static成员
- 移动赋值：和移动构造一致，且相互关联

一些现代C++做法：
- 使用nullptr,而不是0或者NULL，避免重载指针和整形
- 优先使用using别名而不是typedef，别名模板避免::type后最和typename, C++14后type_traits有别名声明
- 优先使用限域enum,防止名称污染，底层类型默认是int
- 不需要的特殊成员函数使用delete显示删除
- 尽量使用const_iterator,非成员版本的begin,end适应范围更广，内置数组类型也支持
- constexpr修饰变量表示编译期常量，constexpr修饰函数表示当参数也是编译期常量时，它可以返回编译期的常量，但也可以作为运行期的函数；C++11时，此类函数只有一个return语句，C++14后限制很宽松
- atomic比mutext性能更好，但它只适合单变量
- 使用override显式重写父类函数，编译期会帮你检查函数签名

初始化方式
- ()：它防止了隐式的变窄转换，而且对于C++最令人头疼的解析也天生免疫，注意二义性问题
- = ：一般不能直接给类
- {}: 统一初始化，编译器热衷于把括号初始化与使std::initializer_list构造函数匹配

exception

# 并发编程
C++11引入了lambda用以创建匿名函数，闭包（enclosure）是lambda创建的运行时对象。依赖捕获模式，闭包持有被捕获数据的副本或者引用。闭包类（closure class）是从中实例化闭包的类。每个lambda都会使编译器生成唯一的闭包类。  

参数传递包括按**引用捕获**和**按值捕获**。  
默认的按引用捕获可能会导致悬空引用。默认的按值捕获对于悬空指针很敏感（尤其是this指针）

- C++14后lambda可以轻易捕获移动对象(初始化捕获)，C++11可以使用std::bind来实现
- lambda的auto&&形参使用decltype来forward
- 尽量使用lambda而不是std::bind，除非是C++11中要移动对象


对比基于线程的编程方式，基于任务的设计为开发者避免了手动线程管理的痛苦，并且自然提供了一种获取异步执行程序的结果的方式。当然，仍然存在一些场景直接使用std::thread会更有优势： 

- 你需要访问非常基础的线程API。C++并发API通常是通过操作系统提供的系统级API（pthreads或者Windows threads）来实现的，系统级API通常会提供更加灵活的操作方式（举个例子，C++没有线程优先级和亲和性的概念）。为了提供对底层系统级线程API的访问，std::thread对象提供了native_handle的成员函数，而std::future（即std::async返回的东西）没有这种能力。
- 你需要且能够优化应用的线程使用。举个例子，你要开发一款已知执行概况的服务器软件，部署在有固定硬件特性的机器上，作为唯一的关键进程。
- 你需要实现C++并发API之外的线程技术，比如，C++实现中未支持的平台的线程池。 

线程通信方式：
- 对于简单的事件通信，基于条件变量的设计需要一个多余的互斥锁，对检测和反应任务的相对进度有约束，并且需要反应任务来验证事件是否已发生。
- 基于flag的原子操作设计避免的上一条的问题，但是是基于轮询，而不是阻塞。
- 条件变量和flag可以组合使用，避免虚假唤醒，但是产生的通信机制很不自然。
- 使用std::promise和future的方案避开了这些问题，但是这个方法使用了堆内存存储共享状态，同时有只能使用一次通信的限制。